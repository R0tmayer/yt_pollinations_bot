import os
import zipfile
import tempfile
import asyncio
import aiohttp
from aiogram import types, Router, F
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from states import GenStates
from keyboards import main_menu_kb, back_kb, params_menu_kb, model_kb, yes_no_kb, skip_kb
from image_generation import generate_image

router = Router()

DEFAULT_PARAMS = {
    "model": "flux", "seed": None, "width": 1920, "height": 1080,
    "image": None, "enhance": False, "transparent": False, "nologo": "true"
}

PARAMS_LABELS = {
    "model": "–ú–æ–¥–µ–ª—å", "seed": "Seed", "width": "–®–∏—Ä–∏–Ω–∞", "height": "–í—ã—Å–æ—Ç–∞",
    "image": "–†–µ—Ñ–µ—Ä–µ–Ω—Å", "enhance": "–£–ª—É—á—à–∏—Ç—å –ø—Ä–æ–º—Ç—ã", "transparent": "–ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Ñ–æ–Ω"
}

async def show_params_menu(message, state):
    data = await state.get_data()
    params = data.get("params", DEFAULT_PARAMS.copy())
    params_text = (
        f"<b>üé® –ú–æ–¥–µ–ª—å:</b> {params.get('model', 'flux')}\n"
        f"<b>üé≤ Seed:</b> {params['seed'] if params['seed'] is not None else '—Å–ª—É—á–∞–π–Ω—ã–π'}\n"
        f"<b>‚ÜïÔ∏è –í—ã—Å–æ—Ç–∞:</b> {params.get('height', 1080)} px\n"
        f"<b>‚ÜîÔ∏è –®–∏—Ä–∏–Ω–∞:</b> {params.get('width', 1920)} px\n"
        f"<b>üñºÔ∏è –†–µ—Ñ–µ—Ä–µ–Ω—Å:</b> {params['image'] if params['image'] else '–Ω–µ—Ç'}\n"
        f"<b>üîÆ –£–ª—É—á—à–∏—Ç—å –ø—Ä–æ–º—Ç—ã:</b> {'–î–∞' if params.get('enhance') else '–ù–µ—Ç'}"
    )
    if params.get('model') == 'gptimage':
        params_text += f"\n<b>üí® –ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Ñ–æ–Ω:</b> {'–î–∞' if params.get('transparent') else '–ù–µ—Ç'}"
    await message.answer(
        f"‚öôÔ∏è <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:</b>\n\n{params_text}\n\n"
        f"–ö–∞–∫ –±—É–¥–µ—Ç–µ –≥–æ—Ç–æ–≤—ã, –ø—Ä–æ—Å—Ç–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç–µ .txt —Ñ–∞–π–ª —Å –ø—Ä–æ–º—Ç–∞–º–∏",
        reply_markup=params_menu_kb(show_transparent=(params.get('model') == 'gptimage')),
        parse_mode='HTML'
    )
    await state.set_state(GenStates.menu)

@router.message(Command("start"))
async def cmd_start(message: types.Message, state: FSMContext):
    await state.clear()
    await message.answer(
        "üëã <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –º–∏—Ä –Ω–µ–π—Ä–æ-–∞—Ä—Ç–∞!</b>\n\n"
        "–Ø ‚Äî –≤–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –ò–ò-—Ö—É–¥–æ–∂–Ω–∏–∫. –ü—Ä–æ—Å—Ç–æ –¥–∞–π—Ç–µ –º–Ω–µ –∏–¥–µ—é, –∏ —è –ø—Ä–µ–≤—Ä–∞—â—É –µ—ë –≤ —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n\n"
        "–ì–æ—Ç–æ–≤—ã —Ç–≤–æ—Ä–∏—Ç—å? –ù–∞–∂–º–∏—Ç–µ '–°–æ–∑–¥–∞—Ç—å —à–µ–¥–µ–≤—Ä'!",
        reply_markup=main_menu_kb(), parse_mode='HTML'
    )

@router.message(F.text == "‚ú® –°–æ–∑–¥–∞—Ç—å —à–µ–¥–µ–≤—Ä")
@router.message(Command("generate"))
async def start_gen(message: types.Message, state: FSMContext):
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏, –∏ –µ—Å–ª–∏ –Ω–µ—Ç - –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º
    data = await state.get_data()
    if "params" not in data:
        await state.update_data(params=DEFAULT_PARAMS.copy())
    
    await show_params_menu(message, state)

@router.message(GenStates.menu, F.text)
async def params_menu_handler(message: types.Message, state: FSMContext):
    text = message.text
    if text.startswith("üé®"):
        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ —Å–ø–∏—Å–∫–∞:", reply_markup=model_kb())
        await state.set_state(GenStates.edit_model)
    elif text.startswith("üé≤"):
        await message.answer("–í–≤–µ–¥–∏—Ç–µ seed (–ª—é–±–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ) –∏–ª–∏ –æ—Å—Ç–∞–≤—å—Ç–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.", reply_markup=skip_kb())
        await state.set_state(GenStates.edit_seed)
    elif text.startswith("‚ÜîÔ∏è"):
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –∂–µ–ª–∞–µ–º—É—é —à–∏—Ä–∏–Ω—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –ø–∏–∫—Å–µ–ª—è—Ö.", reply_markup=skip_kb())
        await state.set_state(GenStates.edit_width)
    elif text.startswith("‚ÜïÔ∏è"):
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –∂–µ–ª–∞–µ–º—É—é –≤—ã—Å–æ—Ç—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –ø–∏–∫—Å–µ–ª—è—Ö.", reply_markup=skip_kb())
        await state.set_state(GenStates.edit_height)
    elif text.startswith("üñºÔ∏è"):
        await message.answer("–û—Ç–ø—Ä–∞–≤—å—Ç–µ –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É (URL) –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ-—Ä–µ—Ñ–µ—Ä–µ–Ω—Å –∏–ª–∏ –æ—Å—Ç–∞–≤—å—Ç–µ –ø–æ–ª–µ –ø—É—Å—Ç—ã–º.", reply_markup=skip_kb())
        await state.set_state(GenStates.edit_ref_image)
    elif text.startswith("üîÆ"):
        await message.answer("–•–æ—Ç–∏—Ç–µ, —á—Ç–æ–±—ã –Ω–µ–π—Ä–æ—Å–µ—Ç—å —É–ª—É—á—à–∏–ª–∞ –≤–∞—à–∏ –ø—Ä–æ–º—Ç—ã –¥–ª—è –±–æ–ª–µ–µ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞?", reply_markup=yes_no_kb())
        await state.set_state(GenStates.edit_enhance)
    elif text.startswith("üí®"):
        data = await state.get_data()
        if data.get("params", {}).get("model") != "gptimage":
            await message.answer("‚ùóÔ∏è –≠—Ç–∞ –æ–ø—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –º–æ–¥–µ–ª–∏ gptimage.")
            return
        await message.answer("–°–æ–∑–¥–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º —Ñ–æ–Ω–æ–º?", reply_markup=yes_no_kb())
        await state.set_state(GenStates.edit_transparent)
    elif text == "‚¨ÖÔ∏è –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é":
        await state.set_state(None) # –ü—Ä–æ—Å—Ç–æ –≤—ã—Ö–æ–¥–∏–º –∏–∑ FSM
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –≥–ª–∞–≤–Ω–æ–π –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π
        await message.answer(
            "üëã <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –º–∏—Ä –Ω–µ–π—Ä–æ-–∞—Ä—Ç–∞!</b>\n\n"
            "–Ø ‚Äî –≤–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –ò–ò-—Ö—É–¥–æ–∂–Ω–∏–∫. –ü—Ä–æ—Å—Ç–æ –¥–∞–π—Ç–µ –º–Ω–µ –∏–¥–µ—é, –∏ —è –ø—Ä–µ–≤—Ä–∞—â—É –µ—ë –≤ —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n\n"
            "–ì–æ—Ç–æ–≤—ã —Ç–≤–æ—Ä–∏—Ç—å? –ù–∞–∂–º–∏—Ç–µ '–°–æ–∑–¥–∞—Ç—å —à–µ–¥–µ–≤—Ä'!",
            reply_markup=main_menu_kb(), parse_mode='HTML'
        )

@router.message(GenStates.edit_model)
async def edit_model(message: types.Message, state: FSMContext):
    if message.text == "‚¨ÖÔ∏è –í –º–µ–Ω—é –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤":
        await show_params_menu(message, state)
        return
    
    # –ò—Å–ø—Ä–∞–≤–ª—è–µ–º –ø–∞—Ä—Å–∏–Ω–≥, —á—Ç–æ–±—ã –æ–Ω –±—Ä–∞–ª –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–ª–æ–≤–æ (–Ω–∞–∑–≤–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏)
    model_name = message.text.split(' ')[-1]
    if model_name not in ["flux", "turbo", "kontext", "gptimage"]:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–∑ —Å–ø–∏—Å–∫–∞.", reply_markup=model_kb())
        return
        
    data = await state.get_data()
    params = data.get("params", DEFAULT_PARAMS.copy())
    params["model"] = model_name
    if model_name != "gptimage":
        params["transparent"] = False
    await state.update_data(params=params)
    await show_params_menu(message, state)

# ... (–ó–¥–µ—Å—å –±—É–¥—É—Ç –æ—Å—Ç–∞–ª—å–Ω—ã–µ edit_* —Ö–µ–Ω–¥–ª–µ—Ä—ã, –æ–Ω–∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã)
async def update_param_and_show_menu(message, state, param_name, value_processor=lambda x: x):
    if message.text == "‚¨ÖÔ∏è –í –º–µ–Ω—é –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤":
        await show_params_menu(message, state)
        return
    
    value = value_processor(message.text)
    if value is None and message.text != "‚è≠Ô∏è –û—Å—Ç–∞–≤–∏—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é":
        # –ü—Ä–æ—Å—Ç–æ –æ—Å—Ç–∞–≤–∏–º –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π, –µ—Å–ª–∏ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä –Ω–µ —Å–ø—Ä–∞–≤–∏–ª—Å—è
        await show_params_menu(message, state)
        return

    data = await state.get_data()
    params = data.get("params", DEFAULT_PARAMS.copy())
    params[param_name] = value
    await state.update_data(params=params)
    await show_params_menu(message, state)

@router.message(GenStates.edit_seed)
async def edit_seed(message: types.Message, state: FSMContext):
    await update_param_and_show_menu(message, state, "seed", lambda x: int(x) if x.isdigit() else None)

@router.message(GenStates.edit_width)
async def edit_width(message: types.Message, state: FSMContext):
    await update_param_and_show_menu(message, state, "width", lambda x: int(x) if x.isdigit() else 1024)

@router.message(GenStates.edit_height)
async def edit_height(message: types.Message, state: FSMContext):
    await update_param_and_show_menu(message, state, "height", lambda x: int(x) if x.isdigit() else 1024)

@router.message(GenStates.edit_ref_image)
async def edit_ref_image(message: types.Message, state: FSMContext):
    await update_param_and_show_menu(message, state, "image", lambda x: x if x != "‚è≠Ô∏è –û—Å—Ç–∞–≤–∏—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é" else None)

@router.message(GenStates.edit_enhance)
async def edit_enhance(message: types.Message, state: FSMContext):
    await update_param_and_show_menu(message, state, "enhance", lambda x: x == "‚úÖ –î–∞")

@router.message(GenStates.edit_transparent)
async def edit_transparent(message: types.Message, state: FSMContext):
    await update_param_and_show_menu(message, state, "transparent", lambda x: x == "‚úÖ –î–∞")

@router.message(GenStates.menu, F.document)
async def handle_file(message: types.Message, state: FSMContext, bot):
    doc = message.document
    if not doc.file_name.endswith(".txt"):
        await message.answer("‚ùóÔ∏è–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ .txt —Ñ–∞–π–ª —Å –ø—Ä–æ–º—Ç–∞–º–∏.")
        return
    user_data = await state.get_data()
    params = user_data.get("params", DEFAULT_PARAMS.copy())
    status_msg = await message.answer("‚úÖ –§–∞–π–ª –ø–æ–ª—É—á–µ–Ω! –ù–∞—á–∏–Ω–∞—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π... ‚è≥")
    with tempfile.TemporaryDirectory() as tmpdir:
        file_path = os.path.join(tmpdir, doc.file_name)
        await bot.download(doc, destination=file_path)
        with open(file_path, "r", encoding="utf-8") as f:
            prompts = [line.strip() for line in f if line.strip()]
        if not prompts:
            await status_msg.edit_text("‚ùóÔ∏è–§–∞–π–ª –ø—É—Å—Ç–æ–π –∏–ª–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π.")
            return
        images_dir = os.path.join(tmpdir, "images")
        os.makedirs(images_dir, exist_ok=True)
        image_paths = []
        total = len(prompts)
        async with aiohttp.ClientSession() as session:
            for idx, prompt in enumerate(prompts, 1):
                img = await generate_image(session, prompt, params)
                if img:
                    img_path = os.path.join(images_dir, f"image_{idx}.jpg")
                    with open(img_path, "wb") as out:
                        out.write(img)
                    image_paths.append(img_path)
                await status_msg.edit_text(f"üñºÔ∏è –ì–µ–Ω–µ—Ä–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {idx} –∏–∑ {total}... ‚è≥")
                await asyncio.sleep(0.5)
        if not image_paths:
            await status_msg.edit_text("‚ùóÔ∏è–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–∏ –æ–¥–Ω–æ–π –∫–∞—Ä—Ç–∏–Ω–∫–∏.")
            return
        await status_msg.edit_text("üì¶ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –§–æ—Ä–º–∏—Ä—É—é –∞—Ä—Ö–∏–≤...")
        zip_path = os.path.join(tmpdir, "images.zip")
        with zipfile.ZipFile(zip_path, "w") as zipf:
            for img_path in image_paths:
                zipf.write(img_path, os.path.basename(img_path))
        await status_msg.edit_text("üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –∞—Ä—Ö–∏–≤ —Å –∫–∞—Ä—Ç–∏–Ω–∫–∞–º–∏...")
        with open(zip_path, "rb") as zipf:
            await message.answer_document(
                types.FSInputFile(zipf.name, filename="images.zip"),
                caption="‚úÖ –í–∞—à –∞—Ä—Ö–∏–≤ —Å –∫–∞—Ä—Ç–∏–Ω–∫–∞–º–∏ –≥–æ—Ç–æ–≤! –°–ø–∞—Å–∏–±–æ –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–æ—Ç–∞.\n\nüè† –î–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –º–µ–Ω—é –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ.",
                reply_markup=main_menu_kb()
            )
        await status_msg.delete()
    await state.clear() 